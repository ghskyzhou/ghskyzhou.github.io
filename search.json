[{"title":"Clique","path":"/2025/04/22/Clique/","content":"CS C++ Code Clique 团Bron-Kerbosch Algorithm 最大团搜索算法Wikipedia OI-Wiki 团(Clique)：一个无向图里面的一组顶点，其中任意两个顶点之间都有一条边相连（完全子图） 极大团(Maximal Clique)：是指一个团，无法通过添加任何新的相邻顶点来扩展它，可以理解为一个图里面的“饱和”团 最大团(Maximum Clique)：是指图中顶点数最多的团（可能有多个） $\\text{Maximum Clique} \\subset \\text{Maximal Clique}$ Bron-Kerbosch算法可以找到图中所有的极大团 三个重要的集合： $R$：当前正在构建的团的集合 $P$：可能扩展$R$的候选项点的集合（与$R$中所有顶点相连） $X$：已经处理过的顶点的集合（避免重复） 轴顶点(Pivot)：是从$P \\cup X$中选择的一个顶点，通常选择邻居最多的顶点（度数最大） 轴优化(Pivoting)思想：如果某个顶点$u$的邻居已经被处理过，那么它的所有邻居顶点$v \\in N(u)$会在其他分支中被处理，当前分支无需重复计算。因此，只需要处理$P\\backslash N(u)$，从而减少递归调用的次数。 Python代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243from collections import defaultdict# 读图函数def read_graph(): first_line = input().strip() n, m = map(int, first_line.split()) graph = defaultdict(set) for _ in range(m): u, v = input().strip().split() graph[u].add(v) graph[v].add(u) return graphdef bron_kerbosch_pivot(graph): def bk(R, P, X): # 如果P和X都是空的，说明R这个团已经是极大团了 if not P and not X: cliques.append(R) return # 选择轴顶点：从P∪X中选邻居最多的顶点 pivot = max(P.union(X), key = lambda v: len(graph[v])) # 只需要处理P中不属于轴顶点邻居的顶点 for v in P.difference(graph[pivot]): neighbors = graph[v] bk(R | &#123;v&#125;, P &amp; neighbors, X &amp; neighbors) P.remove(v) X.add(v) cliques = [] bk(set(), set(graph.keys()), set()) return cliquesif __name__ == &quot;__main__&quot;: graph = read_graph() for node in graph: print(f&quot;&#123;node&#125;: &#123;graph[node]&#125;&quot;) BK_graph = bron_kerbosch_pivot(graph) print(BK_graph) C++代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define MAXN 10001using namespace std;int n, m;int head[MAXN], to[MAXN], nxt[MAXN], tot = 0;vector &lt;int&gt; G[MAXN], maxClique;int maxCliqueSize = 0;//链式前向星加边void addEdge(int u, int v)&#123; to[tot] = v; nxt[tot] = head[u]; head[u] = tot++; G[u].push_back(v);&#125;//二分判断两个点是不是邻居bool isNB(int u, int v)&#123; return binary_search(G[u].begin(), G[u].end(), v);&#125;void BK(vector &lt;int&gt; &amp;R, vector &lt;int&gt; &amp;P, vector &lt;int&gt; &amp;X)&#123; //如果P和X都是空的，说明R这个团已经是极大团了 if(P.empty() &amp;&amp; X.empty()) &#123; if(R.size() &gt; maxCliqueSize) &#123; maxCliqueSize = R.size(); maxClique = R; &#125; return; &#125; //选择轴顶点：从P∪X中选邻居最多的顶点，记为u vector &lt;int&gt; PUX = P; PUX.insert(PUX.end(), X.begin(), X.end()); int u = -1, maxDeg = -1; for(int v : PUX) &#123; int deg = 0; for(int w : P) if(isNB(v, w)) deg++; if(deg &gt; maxDeg) &#123; maxDeg = deg; u = v; &#125; &#125; //将不属于轴顶点邻居的点加入到cand候选列表里 vector &lt;int&gt; cand; for(int v : P) if(!isNB(u, v)) cand.push_back(v); //只需要处理候选列表里的点 for(int v : cand) &#123; vector&lt;int&gt; R2 = R, P2, X2; R2.push_back(v); for(int w : P) if(isNB(v, w)) P2.push_back(w); for(int w : X) if(isNB(v, w)) X2.push_back(w); BK(R2, P2, X2); P.erase(find(P.begin(), P.end(), v)); X.push_back(v); &#125;&#125;int main()&#123; memset(head, -1, sizeof(head)); cin &gt;&gt; n &gt;&gt; m; for(int x = 1; x &lt;= m; x++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, v); addEdge(v, u); &#125; for(int x = 1; x &lt;= n; x++) sort(G[x].begin(), G[x].end()); vector &lt;int&gt; R, P, X; for(int x = 1; x &lt;= n; x++) P.push_back(x); BK(R, P, X); for(int v : maxClique) cout &lt;&lt; v &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125; 12345678910111213141516171819[Python 3.12.5]Sample Input:5 6A BB CB DC ED EA DSample Output:A: &#123;&#x27;B&#x27;, &#x27;D&#x27;&#125;B: &#123;&#x27;A&#x27;, &#x27;C&#x27;, &#x27;D&#x27;&#125;C: &#123;&#x27;B&#x27;, &#x27;E&#x27;&#125;D: &#123;&#x27;B&#x27;, &#x27;A&#x27;, &#x27;E&#x27;&#125;E: &#123;&#x27;C&#x27;, &#x27;D&#x27;&#125;[&#123;&#x27;B&#x27;, &#x27;C&#x27;&#125;, &#123;&#x27;B&#x27;, &#x27;A&#x27;, &#x27;D&#x27;&#125;, &#123;&#x27;E&#x27;, &#x27;C&#x27;&#125;, &#123;&#x27;E&#x27;, &#x27;D&#x27;&#125;]这里能看到，B A D就是唯一的最大团，其余也都是极大团 除了Pivoting优化之外，还有Ordering优化 Ordering Heuristics for k-clique Listing","tags":["CS","C++","Code"],"categories":["Algorithm"]},{"title":"CUHKSZ Notes","path":"/2025/04/13/CUHKSZ_Notes/","content":"CS Just some hand-writing notesStill updating… The reason I chose hand-writing instead of typing is that, I’ve just finished my High Shcool learning and I’ve been using hand-writing notes for years. It’s more convenient for myself, but maybe not so friendly to others. Sorry about this! Maybe later in CSC courses I will try to use typing to note, after my $\\LaTeX$ learning. MAT1001 Calculus IThis is the first note I’ve done in CUHKSZ, so it may be a bit messy. The notes later will be more formal and tidy (I guess). MAT1001https://skyzhou.top/files/MAT1001.pdf MAT1002 Calculus IIUnfinished MAT1002https://skyzhou.top/files/MAT1002.pdf MAT2041 Linear Algebra and ApplicationsUnfinished MAT2041https://skyzhou.top/files/MAT2041.pdf STA2001 Probability and Statistics IUnfinished STA2001https://skyzhou.top/files/STA2001.pdf Transform ZIP(jpgs) to PDFPython Code Generated by Deepseek 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import osimport zipfilefrom PIL import Imagefrom fpdf import FPDFimport globdef zip_to_pdf(zip_path, output_folder=None): &quot;&quot;&quot; 将ZIP文件中的JPG图片合并为PDF 参数: zip_path (str): ZIP文件路径 output_folder (str, optional): 输出PDF的目录，默认为ZIP所在目录 &quot;&quot;&quot; # 检查ZIP文件是否存在 if not os.path.exists(zip_path): raise FileNotFoundError(f&quot;ZIP文件不存在: &#123;zip_path&#125;&quot;) # 设置输出目录 if output_folder is None: output_folder = os.path.dirname(zip_path) # 获取ZIP文件名(不带扩展名) zip_name = os.path.splitext(os.path.basename(zip_path))[0] pdf_path = os.path.join(output_folder, f&quot;&#123;zip_name&#125;.pdf&quot;) # 创建临时目录存放解压文件 temp_dir = os.path.join(output_folder, f&quot;temp_&#123;zip_name&#125;&quot;) os.makedirs(temp_dir, exist_ok=True) try: # 解压ZIP文件 with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zip_ref: zip_ref.extractall(temp_dir) # 获取所有JPG文件 jpg_files = glob.glob(os.path.join(temp_dir, &quot;*.jpg&quot;)) + glob.glob(os.path.join(temp_dir, &quot;*.jpeg&quot;)) if not jpg_files: raise ValueError(&quot;ZIP文件中没有找到JPG图片&quot;) # 按文件名排序 jpg_files.sort() # 创建PDF pdf = FPDF(unit=&quot;pt&quot;) # 使用点(point)作为单位 for jpg_file in jpg_files: # 打开图片获取尺寸 with Image.open(jpg_file) as img: width, height = img.size # 添加新页面并设置尺寸 pdf.add_page(format=[width, height]) pdf.image(jpg_file, x=0, y=0, w=width, h=height) # 保存PDF pdf.output(pdf_path) print(f&quot;成功创建PDF: &#123;pdf_path&#125;&quot;) finally: # 清理临时文件 import time time.sleep(1) # 等待1秒确保文件被释放 for root, dirs, files in os.walk(temp_dir, topdown=False): for name in files: file_path = os.path.join(root, name) try: os.remove(file_path) except PermissionError: print(f&quot;无法删除文件 &#123;file_path&#125;，可能仍被占用&quot;) for name in dirs: os.rmdir(os.path.join(root, name)) try: os.rmdir(temp_dir) except OSError: print(f&quot;无法删除临时目录 &#123;temp_dir&#125;，可能仍有文件被占用&quot;)if __name__ == &quot;__main__&quot;: # 示例用法 zip_file = input(&quot;请输入ZIP文件路径: &quot;).strip(&#x27;&quot;\\&#x27; &#x27;) # 处理可能的引号 zip_to_pdf(zip_file)","tags":["CS"],"categories":["CUHKSZ"]},{"title":"$\\LaTeX$数学公式","path":"/2025/03/20/LaTeX_Mathematics/","content":"CS Code 前言写$\\LaTeX$是现代数学和计算机相关人员必须掌握的一项技能。它可以将UTF-8格式的文字整齐规范地显示出来，还能显示数学公式，可以说现代印刷和电子显示数学公式离不开$\\LaTeX$。 这本书讲的很好，本文也主要围绕这个展开。 The Not So Short Introduction to LATEXhttps://tobi.oetiker.ch/lshort/lshort.pdf 数学公式虽然书本最后的 Things You Shouldn’t Use 里面写到不用＄来写数学公式，但因为这个SkyBlog的Markdown渲染器貌似只支持＄符号而不是 \\() 和 \\[] 的写法，所以就统一用＄来表示了。 数学模式数学模式和正常的模式有两个主要的不同区别： 字符之间的空格&#x2F;换行是会省略掉的 Markdown12$123xyz$ is the same as $ 1 2 3 x y z$ 显示效果$123xyz$ is the same as $ 1 2 3 x y z$ 所有的文字都会被视为数学变量 Markdown1Hello $World!$ 显示效果Hello $World!$ 当然，如果想在$\\LaTeX$里面正常显示文字也是可以的 Markdown1Hello $\\text&#123;World!&#125;$ 显示效果Hello $\\text{World!}$ 基础运算符号常用的加减乘除等号我们可以很清楚的用$+-*&#x2F;&#x3D;$来表示这里再给出叉乘、点乘、除号、不等号的表示 Markdown12$(4 \\times 6) \\div 3 = 8$$5 \\cdot 9 ot= 40$ 显示效果$(4 \\times 6) \\div 3 &#x3D; 8$$5 \\cdot 9 ot&#x3D; 40$ 不等式 Markdown1234$1 &lt; 2$$1 \\leq 2$ vs $1 \\leqslant 2$$2 &gt; 1$$2 \\geq 1$ vs $2 \\geqslant 1$ 显示效果$1 &lt; 2$$1 \\leq 2$ vs $1 \\leqslant 2$$2 &gt; 1$$2 \\geq 1$ vs $2 \\geqslant 1$ 次方，注意这里第二个次方要把(a^2)用{}括起来，表示一个group，不然的话两个2会等高，并不理想 Markdown12$a^2$$&#123;(a^2)&#125;^2$ 显示效果$a^2$${(a^2)}^2$ 根号 Markdown12$\\sqrt&#123;a&#125;$$\\sqrt[n]&#123;a&#125;$ 显示效果$\\sqrt{a}$$\\sqrt[n]{a}$ 分式 Markdown12$\\frac&#123;114514&#125;&#123;1919810&#125;$$\\frac&#123;a+b&#125;&#123;\\frac&#123;c&#125;&#123;d+e&#125;&#125;$ 显示效果$\\frac{114514}{1919810}$$\\frac{a+b}{\\frac{c}{d+e}}$ 逻辑与集合论逻辑运算符与、或、非、条件 Markdown12$p \\land q \\iff \\lnot (p \\implies \\lnot q)$$p \\lor q \\impliedby p \\text&#123;and&#125; q$ 显示效果$p \\land q \\iff \\lnot (p \\implies \\lnot q)$$p \\lor q \\impliedby p \\text{ or } q$ 任意、存在 Markdown12$\\forall_&#123;q&#125; P(q) ot= 0$$\\exists_&#123;q&#125; P(q) = 0$ 显示效果$\\forall_{q} P(q) ot&#x3D; 0$$\\exists_{q} P(q) &#x3D; 0$ 集合、属于、省略号，一般来说$\\LaTeX$的大括号表示只需要一个反斜杠\\就够了，但是这里默认的Markdown渲染器marked需要两个反斜杠\\\\ Markdown12$\\\\&#123;x \\in X: \\exists_n x^n = 1\\\\&#125;$ $\\\\&#123;1, 2, 3, \\ldots, 100\\\\&#125;$ 显示效果$\\{x \\in X: \\exists_n x^n &#x3D; 1\\}$$\\{1, 2, 3, \\ldots, 100\\}$ 集合运算符空集、包含于、并集、交集 Markdown12345$\\emptyset$$A \\subset B \\subseteq C$$A \\supset B \\supseteq C$$A \\subsetneq B \\supsetneq C$$(A \\cap B) \\cup C$ 显示效果$\\emptyset$$A \\subset B \\subseteq C$$A \\supset B \\supseteq C$$A \\subsetneq B \\supsetneq C$$(A \\cap B) \\cup C$ 希腊字母小写用全小写的英语单词，大写用首字母大写的英语单词 Markdown123456789101112131415161718192021222324$\\alpha A$$\\beta B$$\\gamma \\Gamma$$\\delta \\Delta$$\\epsilon E$$\\zeta Z$$\\eta H$$\\theta \\Theta$$\\iota I$$\\kappa K$$\\lambda \\Lambda$$\\mu M$$ u N$$\\xi \\Xi$$o O$$\\pi \\Pi$$\\rho P$$\\sigma \\Sigma$$\\tau T$$\\upsilon \\Upsilon$$\\phi \\Phi$$\\chi X$$\\psi \\Psi$$\\omega \\Omega$ 显示效果$\\alpha A$$\\beta B$$\\gamma \\Gamma$$\\delta \\Delta$$\\epsilon E$$\\zeta Z$$\\eta H$$\\theta \\Theta$$\\iota I$$\\kappa K$$\\lambda \\Lambda$$\\mu M$$ u N$$\\xi \\Xi$$o O$$\\pi \\Pi$$\\rho P$$\\sigma \\Sigma$$\\tau T$$\\upsilon \\Upsilon$$\\phi \\Phi$$\\chi X$$\\psi \\Psi$$\\omega \\Omega$ 变体 Markdown12345$\\varepsilon E$$\\vartheta \\Theta$$\\varpi \\Pi$$\\varsigma \\Sigma$$\\varphi \\Phi$ 显示效果$\\varepsilon E$$\\vartheta \\Theta$$\\varpi \\Pi$$\\varsigma \\Sigma$$\\varphi \\Phi$","tags":["CS","Code"],"categories":["Algorithm"]},{"title":"CUHKSZ-CS修读计划","path":"/2025/03/19/CUHKSZ_CS/","content":"CS 官方修读计划（筛选后）CUHKSZ-CS-Schemehttps://registry.cuhk.edu.cn/sites/default/files/2024-09/Study%20Scheme%20-%20CSE_2024-25%20and%20thereafter_Circular%20%28AB2024_C036%29.pdf 课程代号 课程名称 课程类型 学分 修读情况 东大CS BIO1008 化学与生命科学 学院课程 3 ✅ CSC1003 计算机科学与程序设计导论 学院课程 3 ✅ CSC1004 Java程序设计实验 学院课程 1 ✅ DDA2001 数据科学基础 学院课程 3 ✅ MAT1001 微积分（一） 学院课程 3 ✅ ✅ MAT1002 微积分（二） 学院课程 3 ✅ ✅ MAT2041 线性代数与应用 学院课程 3 ✅ ✅ PHY1001 力学 学院课程 3 STA2001 概率与统计（一） 学院课程 3 ✅ ✅ CSC3001 离散数学 必修科目 3 ✅ CSC3060 计算机系统导论 必修科目 4 CSC3200 数据结构与高级程序设计 必修科目 4 ✅ CSC3150 操作系统 必修科目 3 ✅ CSC4120 算法设计与分析 必修科目 3 ✅ DDA3020 机器学习 必修科目 3 ✅ DDA3005 数值方法 选修科目 3 ✅ CSC3120 程序设计语言原理 选修科目 3 ✅ DDA4210 高等机器学习 选修科目 3 ✅ CSC4140 计算机图形学 选修科目 3 ✅ CSC4100 自然语言处理 选修科目 3 ✅ BIM3001 生物信息学 选修科目 3 ✅ ECE4513 图像处理和计算机视觉 选修科目 3 ✅ CSC3002 C&#x2F;C++程序设计 选修科目 3 CSC3102 高级程序设计实验 选修科目 3 CSC3180 人工智能之基本原理 选修科目 3 CSC4001 软件工程 选修科目 3 CSC4180 编译器设计 选修科目 3 CSC4190 互联网编程与应用 选修科目 3 CSC4303 网络编程 选修科目 3 DDA4220 深度学习与应用 选修科目 3 DDA4320 强化学习 选修科目 3 ECE3200 电子游戏设计与开发 选修科目 3 ECE4016 计算机网络 选修科目 3 MAT3007 最优化 选修科目 3 STA4001 随机过程 选修科目 3 那么，在对比和筛选完东大CS修考范围和港中深有的课之后，还剩下了下面的: 情報数学 (Information Mathematics)形式言語 (Formal Languages)論理学 (Logic)計算機アーキテクチャ (Computer Architecture)デジタル回路 (Digital Circuit) 这些都得靠自己去研究了","tags":["CS"],"categories":["CUHKSZ"]},{"title":"DP by Deepseek","path":"/2025/02/23/Dynamic_Programming_Deepseek/","content":"ACM AI 以下所有内容都由Deepseek生成 动态规划（Dynamic Programming, DP）是解决许多经典问题的强大工具。以下是一些经典的动态规划问题，涵盖了不同的应用场景和难度级别： 1. 背包问题（Knapsack Problem） 问题描述：给定一组物品，每个物品有重量和价值，在不超过背包容量的情况下，选择物品使得总价值最大。 变种： 0-1 背包问题（每个物品只能选一次）。 完全背包问题（每个物品可以选多次）。 多重背包问题（每个物品有数量限制）。 状态转移方程（0-1 背包）：$$dp[i][j] &#x3D; \\max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])$$ 其中 $dp[i][j]$ 表示前 $i$ 个物品在容量 $j$ 下的最大价值。 2. 最长公共子序列（Longest Common Subsequence, LCS） 问题描述：给定两个字符串，找到它们的最长公共子序列（不要求连续）。 状态转移方程：$$dp[i][j] &#x3D; \\begin{cases} dp[i-1][j-1] + 1 &amp; \\text{if } s1[i] &#x3D; s2[j] \\\\max(dp[i-1][j], dp[i][j-1]) &amp; \\text{otherwise}\\end{cases}$$其中 $dp[i][j]$ 表示 $s1$ 的前 $i$ 个字符和 $s2$ 的前 $j$ 个字符的 LCS 长度。 3. 最长递增子序列（Longest Increasing Subsequence, LIS） 问题描述：给定一个数组，找到最长的严格递增子序列。 状态转移方程：$$dp[i] &#x3D; \\max(dp[i], dp[j] + 1) \\quad \\text{for all } j &lt; i \\text{ and } arr[j] &lt; arr[i]$$ 其中 $dp[i]$ 表示以第 $i$ 个元素结尾的最长递增子序列的长度。 4. 编辑距离（Edit Distance） 问题描述：给定两个字符串，计算将一个字符串转换为另一个字符串所需的最少操作次数（插入、删除、替换）。 状态转移方程：$$dp[i][j] &#x3D; \\begin{cases} dp[i-1][j-1] &amp; \\text{if } s1[i] &#x3D; s2[j] \\\\min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 &amp; \\text{otherwise}\\end{cases}$$ 其中 $dp[i][j]$ 表示将 $s1$ 的前 $i$ 个字符转换为 $s2$ 的前 $j$ 个字符所需的最小操作次数。 5. 矩阵链乘法（Matrix Chain Multiplication） 问题描述：给定一系列矩阵，找到一种括号化方案，使得矩阵乘法的计算次数最少。 状态转移方程：$$dp[i][j] &#x3D; \\min_{i \\leq k &lt; j} (dp[i][k] + dp[k+1][j] + p[i-1] \\cdot p[k] \\cdot p[j])$$ 其中 $dp[i][j]$ 表示从第 $i$ 个矩阵到第 $j$ 个矩阵的最小计算次数，$p$ 是矩阵的维度数组。 6. 硬币找零问题（Coin Change） 问题描述：给定一组硬币面额和一个目标金额，计算凑成目标金额的最少硬币数。 状态转移方程：$$dp[i] &#x3D; \\min(dp[i], dp[i - coin] + 1) \\quad \\text{for all } coin \\leq i$$ 其中 $dp[i]$ 表示凑成金额 $i$ 所需的最少硬币数。 7. 最大子数组和（Maximum Subarray Sum） 问题描述：给定一个数组，找到连续子数组的最大和。 状态转移方程：$$dp[i] &#x3D; \\max(dp[i-1] + arr[i], arr[i])$$ 其中 (dp[i]) 表示以第 (i) 个元素结尾的最大子数组和。 8. 最优二叉搜索树（Optimal Binary Search Tree） 问题描述：给定一组键和它们的搜索概率，构建一棵二叉搜索树，使得搜索代价最小。 状态转移方程：$$dp[i][j] &#x3D; \\min_{i \\leq k \\leq j} (dp[i][k-1] + dp[k+1][j]) + \\sum_{l&#x3D;i}^j p[l]$$ 其中 $dp[i][j]$ 表示从第 $i$ 个键到第 $j$ 个键的最小搜索代价。 9. 旅行商问题（Travelling Salesman Problem, TSP） 问题描述：给定一组城市和它们之间的距离，找到一条最短路径，使得旅行商访问每个城市一次并返回起点。 状态转移方程：$$dp[mask][i] &#x3D; \\min_{j \\in \\text{unvisited}} (dp[mask \\oplus (1 &lt;&lt; j)][j] + dist[i][j])$$ 其中 $dp[mask][i]$ 表示在状态 $mask$ 下，从城市 $i$ 出发的最短路径。 总结动态规划问题通常具有 重叠子问题 和 最优子结构 的特点。通过定义状态、状态转移方程和边界条件，可以高效地解决这些问题。以上列出的经典问题涵盖了动态规划的多种应用场景，是学习和掌握动态规划的重要基础。","tags":["Code","ACM","AI"],"categories":["Algorithm"]},{"title":"Java Gomoku Game","path":"/2025/02/22/Java_Gomoku/","content":"Java CS Code Made by Skyzhou IntelliJ IDEA Project Based on JavaFX. An CUHKSZ CSC1004 Assignment (Link) Github Link : Java Gomoku Game NOT OPEN YET IntroductionThis is a simple Gomoku game with GUI based on JavaFX. Only one java code file included. It’s easy to use so nothing is required to introduce, lol. AI ModeA quite simple AI. It will defense you when lining too much or attack when AI will win for like 100% chance. (Shit mountain 300 lines code) Functions Basic Features Preliminary Gomoku Game Rules Java GUI Direct Mouse Control Advanced Features Time Limit AI Players Test Images Thank Jake, SRQ and Leonardo for testing the code!","tags":["CS","Code","Java"],"categories":["Software"]},{"title":"Dynamic Programming","path":"/2025/02/10/Dynamic_Programming/","content":"C++ ACM Code Brief Introduction Dynamic Programming (DP) is a problem-solving technique used to solve complex problems by breaking them down into simpler subproblems. It is particularly useful for optimization problems, where you need to find the best solution among many possibilities. The key idea behind DP is that instead of solving the same subproblem multiple times, you solve it once and store the result (usually in a table or array) for future reference. This technique avoids redundant calculations and improves efficiency, making it much faster than naive recursion. DP is typically used in problems with overlapping subproblems and optimal substructure, meaning the solution to the overall problem can be constructed from solutions to subproblems. Common applications include finding the shortest path, knapsack problems, longest common subsequences, and various combinatorial problems. There are two main approaches to DP: Top-down (Memoization): This involves solving the problem recursively and storing results of subproblems in a cache (usually an array or hash table). Bottom-up (Tabulation): This involves solving all subproblems starting from the smallest one and building up to the solution of the overall problem. Generated by ChatGPT DP is the most important algorithm to learn now. Codeforces DP Tutorial and Problem Listhttps://codeforces.com/blog/entry/67679 Classic Problems Kadane’s Algorithm (Maximum &#x2F; Minimum Contiguous Subarray Sum)Given an array $a$ with $n$ elements. What’s the maximum &#x2F; minimum contiguous subarray sum? This is a very classic DP problem, with its core idea is continuously updating the current subarray sum while traversing the array and records the global maximum. Let’s talk about the maximum first. Define the state $dp[i]$ represents the maximum sum of a contiguous subarray ending at the $i^{th}$ element. And the goal is to find the maximum value among all $dp[i]$. For the $i^{th}$ element, there are two choices: Add it to the previous contiguous subarray Start a new contiguous subarray Thus, the state transition equation is: $$dp[i] &#x3D; max(dp[i-1] + a[i], a[i])$$ What’s more, since the array of $dp$ is linear and we won’t use it later, we can just use a variable $current_sum$ to record. So the code will be easy to write: 123456789int max_sum = -INF, current_sum = 0;for(int x = 1; x &lt;= n; x++)&#123; current_sum = max(current_sum + a[x], a[x]); max_sum = max(max_sum, current_sum); // Update answer&#125;cout &lt;&lt; max_sum &lt;&lt; endl; What about the minimum? It’s simple too, with transition equation: $$dp[i] &#x3D; min(dp[i-1] + a[i], a[i])$$ The most important is, the time complexity is $O(N)$. Stairs ProblemYou are climbing a staircase. It takes $N$ steps to reach to the top. Each time you can either climb 1 or 2 steps. And you can make most $K$ jumps. In how many distinct ways can you climb to the top? We have $N$ steps to take, and each step can be $k$(from $0$ to $K$) jumps. So we need to have a 2-dimensional dp array, let’s say $dp[i][k]$, with $i$ from $0$ to $N$, $k$ from $0$ to $K$. Moreover, the transition equation will be $$dp[i][k] &#x3D; dp[i-1][k-1] + dp[i-2][k-1]$$for sure. And the answer will be $dp[N][K]$. Minimum Path SumGiven a grid of $n$ x $m$, find a path from the top-left to the bottom-right corner that minimizes the sum of numbers along the path. You can only move right or down. And you can’t make two consecutive steps down. For the grid walking we need a 2-dimensional array $s[i][j]$, but “can’t make two consecutive steps down” is also a state to consider. Thus, the array can be $dp[i][j][2]$, where $dp[i][j][0]$ refers to $s[i][j]$ and the previous step is “walking right”, similarily, $dp[i][j][1]$’s previous step is “walking down”. Therefore, the transition equation will be$$dp[i][j][0] &#x3D; min(dp[i][j-1][0], dp[i][j-1][1]) + grid[i][j]$$and$$dp[i][j][1] &#x3D; dp[i-1][j][0] + grid[i][j]$$(because we can’t make two consecutive steps down). And the answer will be $min(dp[n][m][0], dp[n][m][1])$. In dynamic programming problems, you must think what is important so far after we made some decisions, after we already chose some numbers, or in graghs after we got to this vertex. Line of winesThere are $N$ wines in a row. Each year you sell either the leftmost or the rightmost wine. The $i^{th}$ wine has initial price $p[i]$ and price $k*p[i]$ in the $k^{th}$ year. What is the maximum possible total profit? Since the choose order will affect the profit, and each choose can’t be easily conclued by sorting, greedy is useless here and it won’t lead to an optimal solution. Considering the middle status, e.g. We have sold the $1^{st}$ and the $N^{th}$ wines after 2 years, remaining the $2^{nd}$ to the $(N-1)^{th}$ wines. So we have two variables $L$(remaining left), $R$(remaining right), and years past $Y$ will be easily calculated. We set the array as $dp[L][R]$. So the transition equation will be $$dp[L][R] &#x3D; max(Y·p[R]+dp[L+1][R], Y·p[R]+dp[L][R-1])$$ One tricky thing here is to figure out in what order we should go through the states. The dp array should be initialized like $dp[i][i] &#x3D; p[i]*N$, which is the last wine’s score. And the answer will be $dp[1][N]$. 123456789101112for(int x = 1; x &lt;= N; x++) dp[x][x] = p[i] * N;for(int L = N; L &gt;= 1; L--)&#123; for(int R = L; R &lt;= N; R++) // This is a valid order &#123; int Y = N-(R-L+1); dp[L][R] = max(Y*p[R]+dp[L+1][R], Y*p[R]+dp[L][R-1]); &#125;&#125;cout &lt;&lt; dp[1][N] &lt;&lt; endl; // Answer","tags":["C++","Code","ACM"],"categories":["Algorithm"]},{"title":"东京大学CS修考","path":"/2025/01/22/JPN_UTokyo/","content":"JPN CS Examinations are held twice a year: Summer Entrance Examinations and Winter Entrance Examinations. 考试科目情报理工共通数学微积分（解析学）核心考点： 微分方程（ODE&#x2F;PDE） 多元函数极值、二重积分 泰勒展开、麦克劳林级数 曲线积分、广义积分 推荐教材： 《演習 大学院入試問題[数学]I》（小黄书） 《同济高等数学》（国内考研参考） MIT 微积分公开课（提升理解） 线性代数核心考点： 特征值&#x2F;特征向量、矩阵对角化 行列式计算、逆矩阵、矩阵 n 次方 线性空间、线性映射 推荐教材： MIT Gilbert Strang《线性代数》（必看） 《演習線形代数》（寺田文行） 3Blue1Brown 线性代数可视化课程（辅助理解） 概率统计核心考点： 伯努利分布、泊松分布、指数分布 中心极限定理、条件概率 信息论相关（如熵、编码理论，部分专攻可能涉及） 推荐教材： 《概率导论》（Dimitri P. Bertsekas，神书） 《弱点克服 確率・統計》（日本备考书） 英语TOEFL scores will be used and no written examinations 尽量考到托福100分吧 计算机科学 情報数学 (Information Mathematics) 数値計算 (Numerical Algorithms) 離散数学 (Discrete Mathematics) アルゴリズムと計算量 (Algorithms and Complexity) 形式言語 (Formal Languages) 論理学 (Logic) プログラミング言語論 (Programming Languages) 計算機アーキテクチャ (Computer Architecture) デジタル回路 (Digital Circuit) オペレーティングシステム (Operating Systems) 機械学習 (Machine Learning) グラフィクス (Graphics) 自然言語処理 (Natural Language Processing) バイオインフォマティクス (Bioinformatics) コンピュータビジョン (Computer Vision) 日本修考历年真题https://runjp.com/ コンピューター科学書籍https://www.i.u-tokyo.ac.jp/edu/course/cs/references.shtml 過去問アーカイブhttps://www.i.u-tokyo.ac.jp/edu/entra/examarchive.shtml 申请需要文件 申请表格 Application Form 官网申请系统可以下载 成绩证明书 Academic Transcripts CUHKSZ GPA Form 学位证明 Certificate of Expected Graduation and Degree CUHKSZ Degree 托福分数 TOEFL Score 考试费 Examination Fee 3万円（1500人民币） 东大安全管制确认表 U-Tokyo Security Export Control Confirmation Form 时间线以28年10月入学为例，需要提前半年开始准备申请。 flowchart TD stg1[\"线上申请阶段 2028.5.31-2028.6.6\"] stg2[\"线下考试通知 2028.7.16\"] stg3[\"线下考试 2028.8.15-2028.8.26\"] stg4[\"考试通过通知 2028.9.2\"] stg5[\"准备入学 2028.10\"] stg1 --> stg2 stg2 --> stg3 stg3 --> stg4 stg4 --> stg5 研究计划书?","tags":["CS","JPN"],"categories":["Japanese"]},{"title":"日本語の勉強","path":"/2025/01/19/JPN_Main/","content":"JPN 为什么学日语？因为想考日本计算机科学进修生，想了解日本文化，有机会的话想在日本工作。 如何学日语？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日语学习方面。以网课为主，现在很多网课也比较廉价，但是一定要是给钱的，免费的肯定有水分在里面。自己看书的话一定是枯燥的，是个人都很难坚持下去。教授讲到语言学习，对于我们来说最重要的是听，尤其是现在18岁，非常年轻的阶段，语言学习一定是以听为主，以看为辅，背单词也是要听，更要读出来。大一开始学完全是可以的，至少大四达到N2及以上水平，日本的大学当然更喜欢用日语交流而不是英语。ChatGPT是个很好的工具，可以多问。–松永さん 学习日语的方法？一定要系统、详细地学，而不是碎片化的 ⭐⭐⭐⭐⭐ Anki背单词 无敌，极高效的背词法（有APP） ⭐⭐⭐⭐⭐ 北大《综合日语》微信公众号 《综合日语》公众号https://mp.weixin.qq.com/s?__biz=MzI0NzQ2ODEwOQ==&mid=2247500387&idx=1&sn=3058bf180b6171fdcf2b5d81796a6eb4&chksm=e9ad1b41deda9257600ba288ce32c5c84d0fd08b399cf0787f0e223cad69785a5125231c7589&scene=21#wechat_redirect ⭐⭐⭐⭐⭐ 北京大学《综合日语》 PDF已存 ⭐⭐⭐⭐ 羊驼日语单词APP 免费且较干净 ⭐⭐⭐⭐ 《标准日本语》 电子版&#x2F;纸质版 ⭐⭐⭐ B站野生免费课程 ⭐⭐ 价格高昂的神秘课外班 言葉の勉強は日々の努力の積み重ねです 学习进度？背单词用的是羊驼日语APP，然后上面没有《综合日语》，但我看《新编日语》的词汇表跟《综合日语》相近，而且难度曲线也还行，就选用了《新编日语》。《标准日本语》单词跟《综合日语》的区别就有点大。 背完了新编日语第一册之后，想巩固一下N5-N4的单词，于是又开始用Anki APP，这个是真的科学又高效。 WRD 背单词进度 正常 17% KR 《新编日语》第一册单词 1123 &#x2F; 1123 已完成 100% KR 《新编日语》第二册单词 0 &#x2F; 1435 正常 0% KR 《新编日语》第三册单词 0 &#x2F; 1415 正常 0% KR 《新编日语》第四册单词 0 &#x2F; 1375 正常 0% KR N5词汇 300 &#x2F; 875 正常 40% KR N4词汇 0 &#x2F; 791 正常 0% KR N3词汇 0 &#x2F; 1655 正常 0% KR N2词汇 0 &#x2F; 2870 正常 0% 语法方面目前用的是北大的《综合日语》教材和公众号。 JPN 《综合日语》第一册 正常 26% KR 第1-4课 五十音图和语音学习 第1课 あかさたな、声调第2课 はまやらわ、浊音和半浊音第3课 拨音、长音、促音第4课 拗音、数字 已完成 100% KR 第5课 新生活 ユニット１ はじめましてユニット２ 家族の写真ユニット３ 京華大学紹介 已完成 100% KR 第6课 キャンパス・スケジュール ユニット１ キャンパスユニット２ スケジュールユニット３ サークル情報 已完成 100% KR 第7课 日本語の勉強 ユニット１ 日本語学習ユニット２ユニット３ 正常 11% KR 第8课 ユニット１ユニット２ユニット３ 正常 0% KR 第9课 ユニット１ユニット２ユニット３ 正常 0% KR 第10课 ユニット１ユニット２ユニット３ 正常 0% KR 第11课 ユニット１ユニット２ユニット３ 正常 0% KR 第12课 ユニット１ユニット２ユニット３ 正常 0% KR 第13课 ユニット１ユニット２ユニット３ 正常 0% KR 第14课 ユニット１ユニット２ユニット３ 正常 0% KR 第15课 ユニット１ユニット２ユニット３ 正常 0%","tags":["JPN"],"categories":["Japanese"]},{"title":"Java Chat Room","path":"/2025/01/16/Java_Chat_Room/","content":"Java CS Code Made by Skyzhou IntelliJ IDEA Project Based on JavaFX, MySQL. An CUHKSZ CSC1004 Assignment (Link) Github Link : Java Chat Room NOT OPEN YET IntroductionA simple Java chatroom with GUI based on JavaFX. Two codes included. Server code running on local port 8023, with JDBC’s MySQL “jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;JavaChat”. Thread and socket are applied. Client code can be run for serval times, which are not conflicted with each other. Socket still using local port 8023. After entered the username you will be able to send messages in the chatroom, and ID will be assigned automatically. You can use “Ctrl + F” to start a search window in the client, where you can search for any messages or users sent before. The MySQL database is built on local MySQL. So you need to create a database JavaChat before starting the server code, and tables log and users are required. You can initialize the database like this (if you have MySQL): 1234CREATE DATABASE JavaChat;USE JavaChat;CREATE TABLE users(id INT, name VARCHAR(100));CREATE TABLE log(IND INT, text VARCHAR(1000)); After initialize the database, you can launch IDEA and open the project. Set your own JavaFX library. Run the server.java using IDEA’s run “Server”. Then run Main.java using IDEA’s run “Run JavaFX”. Functions Basic Features Multithreading Implementation Chat Room Functions Message Display Advanced Features Chat Record Storage Search Function Test Images Thank Jake and SRQ for testing the code!","tags":["CS","Code","Java"],"categories":["Software"]},{"title":"Skyzhou's Luogu Blog","path":"/2025/01/15/Skyzhou_Luogu_Blog/","content":"C++ ACM Code blog写多了之后发现洛谷这个专栏没有类似于列表图之类的分类方式，然后堆在一起查询起来也很慢，于是就有了现在这篇汇总 算法·理论 基础 快速排序 二分答案 快读&amp;快写 动态规划 归并排序与逆序对 图论 最短路 最小生成树 链式前向星与网络流 Tarjan 数据结构 二叉树&amp;多叉树 倍增&amp;LCA 线段树 ST表 树状数组 莫队算法 数学 快速幂&amp;矩阵快速幂 同余 字符串 哈希 前缀函数与KMP KMP字符串匹配 Trie字典树 AC自动机 其他 题解 P2783 有机化学之神偶尔会作弊 CSP-S 2022 策略游戏 CSP-S 2022 星战 游记 CSP2022游记 NOIP2022游记 ICPC2024昆明游记","tags":["C++","Code","ACM"],"categories":["Algorithm"]},{"title":"Hello World","path":"/2025/01/14/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"Sky","path":"/about/index.html","content":"About Me 我是Sky 坐标广东，目前是大学生，主修Computer Science方向，喜欢没事干敲点东西 打过算法竞赛，但真的很菜 Social Media Codeforces Luogu Skyzhou666https://www.luogu.com.cn/user/713080 Steam Skyzhouhttps://steamcommunity.com/id/Skyzhou666/ Bilibili Skyzhou_https://space.bilibili.com/67500150 OSU! (mania 4k) QQ 3178309197WX Skyzhou2 欢迎随便扩列"},{"title":"My Favorite","path":"/favsites/index.html","content":"Websites W3schoolsProgram Learning東大CS書籍リストComputer Science日本修士历年真题Japanese MasterJiumo Search电子书搜索Stellar WikiHexo Themeいらすとやフリー素材集日本の可愛いの素材东方狗下载站東方Project咕咕番免费在线看番Bangumi 番组计划https://bangumi.tv/宅方社ACG社区韩小韩WebAPI免费的API接口IMG在线编辑免费在线编辑图片的工具 gal的资源站太容易被干了就不放出来了 Friends LegendStane超闻逸事"}]